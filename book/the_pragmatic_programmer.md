# 실용주의 프로그래머

## 1장 실용주의 철학
### Topic 1 당신의 인생이다
```text
많은 개발자들이 불만에 차있다. 현재 업무에 갇혀 있거나, 기술의 변화를 쫓아가지 못하거나, 재택 근무를 하고 싶거나 등

직접 바꿔라!

소프트웨어 개발은 구직자에게 주도권이 있는 직업 순위 중 상위권이다.

기술에 뒤쳐지는 기분이 든다면 여가 시간을 쪼개서 공부하고 재택 근무를 하고 싶으면 가능한지 물어보아라.

주도적으로 행동하여 기회를 잡아라.
```
### Topic 2 고양이가 내 소스 코드를 삼켰어요
```text
실용주의 철학의 초석 중 하나는 자신과 자신의 행동에 책임을 지는 것이다.

잘 나가는 프로젝트에서도 납품이 늦어지거나 예상치 못했던 기술적 문제가 발생 할 수 있다.

이런 일을 우리는 전문가답게 처리하려고 노력하며, 정직하고 솔직해져야 한다.

그리고 여러분의 팀이 여러분을 믿고 의지할 수 있어야 한다.

연구에 따르면 창의성과 공동 작업에는 팀 내의 신뢰가 절대적으로 필요하다고 한다.

신뢰에 바탕을 둔 환경에서 생각과 아이디어를 제안 할 수 있다.

또한 결과에 대한 책임을 지기로 했다면 나중에 그 결과를 감당해야 할 것이다.

실수하거나 잘못된 판단을 내렸다면, 정직하게 인정하고 다른 방안을 제안하도록 노력하라.

"고양이가 내 소스 코드를 삼켰어요." 라고 말해 봐야 별 도움이 안 될 것이다.

변명 말고 대안을 제시하라. 안된다고 하지 말고 상황을 개선하기 위해 무엇을 할 수 있는지 설명하라.
```
### Topic 3 소프트웨어 엔트로피
```text
소프트웨어 개발에 엔트로피의 증가는 우리에게 많은 영향을 끼친다.

엔트로피는 시스템 내의 무질서한 정도를 가리키는 물리학 용어이다.

소프트웨어의 무질서도가 증가할 때 우리는 이를 '소프트웨어의 부패' 또는 '기술 부채' 라고 부른다.

언젠가는 갚을 수 있다고 생각하지만 아마 갚지는 않을 것이다.

도심에서 아름답고 깨끗한 건물이 있는 반면, 썩어 가는 유령선 같은 건물이 있다.

도시 부패를 연구하는 사람들은 유인 메커니즘인 깨진 창문을 발견했다.

방치된 깨진 창문 하나가 둘이 되고 쓰레기를 함부로 버리고 낙서를 시작한다.

깨진 창문을 내버려 두지 말라.

나쁜 설계, 잘못된 결정, 형편없는 코드 등 모두 깨진 창문이다.

물론 가장 좋은 것은 창문을 깨트리거나 망가트리지 않는 것이다.

깨진 창문 하나는 내리막길로 가는 첫걸음이다.

명심하라. 깨진 창문은 없어야 한다. 
```
### Topic 4 돌멩이 수프와 삶은 개구리
```text
군인들이 전쟁이 끝나고 집으로 가는 길에 마을이 보여 배고픔을 해결하기 위해 갔다.

하지만 전쟁으로 인해 식량이 부족하여 아무도 대접해주지 않았다.

그러자 군인들은 냄비에 물을 끓이고 돌멩이를 넣었다.

사람들이 "그것만 집어넣는 거에요?" 라고 묻자 군인들은 말했다. "당연하지요. 누군가는 당근을 몇 개 넣으면 더 맛있다고들 하지만요."

사람들은 집에서 당근을 가져왔고 다시 물었다. "그럼 된 건가요?"

"흠, 감자 몇 개 더 넣으면 묵직한 맛이 날 텐데요." 라고 군인이 말하자 다른 사람들이 감자를 가져왔다.

이렇게 몇 번을 반복하자 군인들과 마을 사람들은 오랜만에 제대로 된 식사를 할 수 있었다.

이야기에는 다양한 교훈이 있지만 가장 중요한 것은 군인들이 하나의 촉매가 되어 불가능한 것을 가능하게 했다는 점이다.

우리는 간혹 이 군인들을 모방해야 할 때가 있다. 다른 사람들이 각자 자신의 자원을 지키려고 한다면 돌멩이를 내놔야 할 때다.

한편 돌멩이 수프 이야기는 조심스럽고 점진적인 속임수에 관한 이야기이기도 하다.

마을 사람들은 돌멩이 수프에 대해 생각하느라 다른 일들은 까맣게 잊어버렸다.

프로젝트는 서서히, 하지만 가차없이 구제불능인 상태가 되어 버린다.

차가운 물에 개구리를 넣고 조금씩 물을 덮히면 개구리는 삶아질 때까지 그냥 그대로 있을 것이다.

개구리처럼 되지 말자. 당장 하고 있는 일에만 정신을 쏟지 말고, 주변에서 무슨 일이 벌어지는지 늘 살펴보라. 
```
### Topic 5 적당히 괜찮은 소프트웨어
```text
완벽한 것을 만들어 내기란 불가능하다. 특히 버그 없는 소프트웨어는 더더욱.

'적당히 괜찮은' 이라는 표현은 너절하거나 형편없는 코드를 의미하지 않는다. 시스템이 성공하려면 사용자의 요구 사항을 충족해야 한다.

여러분이 생산해 낸 것이 적당히 괜찮게 사용자의 요구를 충족하는지 결정하는 과정에 사용자가 참여할 기회를 가져야 한다.

또한 완벽하게 훌륭한 프로그램을 과도하게 장식하거나 지나칠 정도로 다듬느라 망치지 말라.

그냥 넘어가도 코드를 현재 상태로 한동안 그대로 놓아두라. 완벽하지 않을 수도 있지만 그래도 괜찮다.

완벽해지기란 불가능하다. 멈춰야 할 때를 알라.
```
### Topic 6 지식 포트폴리오
```text
우리는 프로그래머들이 컴퓨터, 애플리케이션 도메인 등에 대해 알고 있는 모든 사실과 경험을 그들의 '지식 포트폴리오' 로 생각해보길 좋아한다.

지식 포트폴리오 관리는 투자 포트폴리오 관리와 매우 유사하다.

1. 진지한 투자자는 주기적으로 투자하는 습관이 있다.
2. 장기적인 성공의 열쇠는 다각화다.
3. 똑똑한 투자자는 보수적인 투자와 위험이 크지만 보상이 높은 투자 사이에서 포트폴리오의 균형을 잘 맞춘다.
4. 투자자는 최대 수익을 위해 싸게 사서 비싸게 팔려고 한다.
5. 포트폴리오는 주기적으로 재검토하고 재조정해야 한다.

그런데 포트폴리오의 종잣돈이 될 지식 자산을 공급하는 최선의 길은 무엇일까? 여기에 몇 가지 제안을 한다.

- 매년 새로운 언어를 최소 하나는 배워라
- 기술 서적을 한 달에 한 권씩 읽어라
- 기술 서적이 아닌 책도 읽어라
- 수업을 들어라
- 지역 사용자 단체나 모임에 참여하라
- 다른 환경에서 실험해 보라
- 요즘 흐름을 놓치지 말라

마지막으로 중요한 점은 여러분이 읽거나 듣는 것에 대해 비판적으로 생각하는 것이다.

여러분의 포트폴리오에 있는 지식을 정확히 유지할 수 있도록 하고 업체나 매체의 과대광고에 흔들리지 않아야 함을 명심하라.
```
### Topic 7 소통하라!
```text
청중을 알라

그저 말하는 것만으로는 부족하다. 전달하려는 내용을 제대로 전달하고 있는 경우에만 소통하고 있다고 할 수 있다.
그렇게 하기 위해서는 청중의 요구와 관심, 능력을 이해할 필요가 있다. 소통하면서 청중에 대한 지식을 쌓아 나가라.

말하고 싶은게 무언지 알라

비즈니스에서 사용하는 조금 더 격식을 갖춘 형태의 의사소통에서 가장 어려운 부분은 아마도 여러분이 말하고자 하는 것이 정확히 무엇인지 생각해 내는 일일 것이다.
무엇을 말할지 미리 계획하라. 의사소통하고 싶은 아이디어들을 적은 다음 제대로 전달하는 데 필요한 전략을 몇 개 세워라.
상대가 무엇을 원하는지 알았다면 원하는 것을 이루어 주자.

때를 골라라

청중이 무엇을 듣기 원하는지 이해하려면 그들의 우선순위를 알아야 한다.
말하는 내용뿐 아니라 말하는 시점도 적절하게 해라.

스타일을 골라라

전달하는 스타일을 청중에 어울리도록 조정하라. 어떤 사람은 좀 격식 있는 그저 '사실'만 전달하는 브리핑을 원하고,
또 어떤 사람은 본론에 들어가기 전에 한참동안 다방면의 한담을 원한다.
뭐가 좋을지 모르겠거든 물어보라.

멋져 보이게 하라

여러분의 아이디어는 중요하다. 그러니 마땅히 청중에게 멋지게 전달하기 위한 수단을 준비해야 한다.
오늘날 형편없어 보이는 출력물을 만드는 것에 대한 변명은 용납되지 않는다.
현대의 소프트웨어는 여러분이 마크다운을 사용하든 워드 프로세서를 사용하든 상관없이 눈부신 출력물을 만들어 낼 수 있다.

청중을 참여시켜라

우리는 우리가 만드는 문서 자체보다 문서를 만드는 과정이 더 중요해지는 경우를 자주 목도한다.
가능하다면 독자가 문서 초안에 참여하도록 하라. 피드백을 받고 그들의 머릿속을 도용하라.

경청하라

다른 사람들이 여러분이 하는 말을 경청해 주길 바란다면 사용할 수 있는 기법이 하나 있다. 그들의 말을 경청하는 것이다.
질문을 해서 사람들이 이야기를 하도록 북돋우거나, 토론의 내용을 그들 자신의 표현으로 다시 말해 달라고 요청하라.
회의를 대화로 바꾸면 생각을 좀 더 효과적으로 전달할 수 있을 것이다.

응답하라

누군가에게 질문을 했는데 아무런 응답이 없다면 그가 무례하다고 느낄 것이다. 언제나 이메일과 음성 메시지에 답을 하라.
심지어 "다음에 답해 드리겠습니다." 이더라도.
늘 사람들에게 응답해 주면 때때로 저지르는 실수에 대해 훨씬 더 관대해질 것이다.

문서화

실용주의 프로그래머는 문서화를 전체 개발 프로세스의 필요 불가결한 부분으로 받아들인다.
노력을 중복으로 들이거나 시간을 낭비하지 말고 문서를 늘 손에 닿는 가까운 곳에 두면 된다. 바로 코드 안에 말이다.
소스 코드의 주석으로 보기 좋은 문서를 쉽게 생성할 수 있다.
그렇다고 해서 모든 함수나 자료 구조, 타입 정의에 무조건 주석을 달아야 한다는 주장에 동의하는 것은 아니다.
이런 기계적인 주석은 오히려 코드 유지 보수를 어렵게 만든다.
소스 코드에 다는 주석은, 프로젝트에서 쉽게 누락되는 다른 곳에서 문서화할 수 업슨 부분을 문서화하기에 최적의 기회다.

```

## 2장 실용주의 접근법
### Topic 8 좋은 설계의 핵심
```text
좋은 설계는 나쁜 설계보다 바꾸기 쉽다.

잘 설계된 코드는 바뀜으로써 사용하는 사람에게 맞춰져야 한다. 그래서 우리는 ETC (Easier To Change) 원칙을 따른다.

가치는 여러분이 결정을 내리게 도움을 주는 것이다. 소프트웨어라는 틀에서 생각해보면 ETC 는 선택의 갈림길에서 도움을 주는 안내자다.

ETC 에는 암묵적인 전제가 있다. 바로 여러 길 중 어떤 길이 미래의 변경을 쉽게 만드는지 알 수 있다는 것이다.
```
### Topic 9 DRY: 중복의 해악
```text
소프트웨어를 신뢰성 높게 개발하는 유일한 길, 개발을 이해하고 유지 보수하기 쉽게 만드는 유일한 길은 

우리가 DRY (Don't Repeat Yourself) 라 부르는 원칙을 따르는 것이라 생각한다.

'모든 지식은 시스템 내에서 단 한 번만, 애매하지 않고 권위 있게 표현되어야 한다.'

DRY 를 따르지 않으면 똑같은 것이 두 군에 이상에 표현될 것이다. 하나를 바꾸면 나머지도 바꿔야 함을 기억해야 한다.

DRY 는 지식의 중복, 의도의 중복에 대한 것이다. 똑같은 개념을 다른 곳 두 군데에서 표현하면 안 된다는 것이다.

주석도 마찬가지다. 쓸데없는 주석은 코드와 중복일 뿐이다.

아마 발견하거나 없애기 가장 어려운 유형의 중복은 같은 프로젝트에서 일하는 개발자들 사이에서 발생할 것이다.

최선책은 개발자 간에 적극적이고 빈번한 소통을 장려하는 것이다.

일일 스크럼 스탠드업 미팅을 운영하거나 한 사람을 프로젝트 사서로 임명하거나 등
```
### Topic 10 직교성
```text
직교성이란 기하학에서 빌려온 용어로 그래프의 축과 같이 두 직선이 직각으로 만나는 경우 직교한다고 말한다.

컴퓨터 과학에서 이 용어는 일종의 독립성이나, 결함도 줄이기를 의미한다.

잘 설계된 시스템에서는 데이터베이스 코드가 사용자 인터페이스와 서로 직교할 것이다.

데이터베이스와 인터페이스는 서로 영향을 주지 않으면서 자기 자신을 교체할 수 있다.

직교성은 생산성을 향상시켜주며 리스크는 감소시킨다.

다음은 직교성을 유지하기 위한 몇 가지 기법이다.

1. 코드의 결합도를 줄여라
2. 전역 데이터를 피하라
3. 유사한 함수를 피하라

직교성은 Topic 9 DRY 원칙과도 밀접한 관계가 있다. 

DRY 원칙은 시스템 내부의 중복을 최소화하고, 직교성은 시스템 컴포넌트 간의 상호 의존도를 줄인다.
```
### Topic 11 가역성
```text
가역성이란 초기 상황으로 되돌아 올 수 있는 성질을 의미한다.

이 책의 많은 주제는 유연하고 적응 가능한 소프트웨어를 만드는 방법에 초점을 맞추고 있다.

특히 DRY 원칙, 결합도 줄이기, 외부 설정 사용하기를 따른다면 중요하면서도 되돌릴 수 없는 결정의 수를 줄일 수 있다.

되돌릴 수 없는 결정을 줄여야 하는 까닭은 우리가 프로젝트 초기에 늘 최선의 결정을 내리지는 못하기 때문이다.

웹 브라우저 기반 애플리케이션으로 시작한 프로젝트가 중간에 모바일 앱으로 변경된다면 바꾸는 것이 얼마나 어려울까?

이상적인 상황이라면 적어도 서버 쪽은 큰 변화가 없어야 한다. HTML 렌더링을 걷어내고 API 로 대체하기만 하면 될 것이다.

결정이 바뀌지 않을 것이라 가정하고서 발생할지도 모를 우연한 사건에 대비하지 않는 데에서 실수가 나온다.

결정이 돌에 새겨진 것이 아니라 바닷가의 모래 위에 쓰인 글씨라 생각하라.

언제든지 큰 파도가 글씨를 지워버릴 수 있다.
```
### Topic 12 예광탄
```text
총알이 공기 중에 밝은 줄무늬의 궤적을 남기는 것을 볼 수 있는데, 이런 줄무늬는 예광탄이 만드는 것이다.

예광탄은 일반 탄환들 사이에 일정한 간격으로 끼어 있고, 이 궤적을 피드백 삼아 조준을 재조정한다.

프로젝트에서도 예광탄이 필요하다.

코딩에서 동일한 효과를 얻으려면 우리를 요구 사항으로부터 최종 시스템의 일부 측면까지 빨리, 눈에 보이게, 반복적으로 도달하게 해 줄 무언가를 찾아야 한다.

시스템을 정의하는 중요한 요구 사항을 찾아라. 의문이 드는 부분이나 가장 위험이 커 보이는 곳을 찾아라.

이런 부분의 코드를 가장 먼저 작성하도록 개발 우선순위를 정하라.

예광탄 개발 방법은 '프로젝트는 결코 끝나지 않는다.'는 견해와도 일맥상통한다. 변경 요청과 기능 추가 요청은 언제나 계속 들어오기 마련이다.

예광탄 개발 방법은 점진적인 접근 방법이다.

예광탄 코드 접근 방법에는 여러 장점이 있다.

1. 사용자가 뭔가 작동하는 것을 일찍부터 보게 된다
2. 개발자가 들어가서 일할 수 있는 구조를 얻는다
3. 통합 작업을 수행할 기반이 생긴다
4. 보여줄 것이 생긴다
5. 진행 상황에 대해 더 정확하게 감을 잡을 수 있다

예광탄은 지금 맞히고 있는 것이 무엇인지 보여준다. 그러나 그것이 꼭 목표물이라는 보장은 없다. 그럴 경우 목표물에 맞을 때까지 조준을 옮겨야 한다. 이것이 핵심이다.

프로토타이핑과 다를 바 없다고 생각하는 사람도 있을 것이다.

프로토타입은 최종 시스템의 어떤 특정한 측면을 탐사해 보는 것이 목표다.

진짜 프로토타입 방식을 따른다면 프로토타입은 어떤 개념을 실험해 보느라 대충 끼워 맞추어 구현한 것이므로 모두 버려야 한다.

하지만 예광탄 코드는 기능은 별로 없지만 완결된 코드이며, 최종 시스템 골격 중 일부가 된다.
```
### Topic 13 프로토타입과 포스트잇
```text
소프트웨어 프로토타입은 위험 요소를 분석하고 노출시킨 후, 이를 매우 저렴한 비용으로 바로잡을 기회를 얻는 것이다.

프로토타입을 반드시 코드로 작성해야 한다고 생각하기 쉬운데 꼭 그럴 필요는 없다.

포스트잇은 작업 흐름이나 애플리케이션 로직과 같이 동적인 것을 프로토타이핑할 수 있는 훌륭한 도구다.

사용자 인터페이스 프로토타입은 화이트보드에 그림을 그려서 만들 수도 있고, 그림판 프로그램, 인터페이스 빌더 등을 이용해 기능은 구현하지 않고 만들어 볼 수 있다.

프로토타입은 제한된 몇 가지 질문에 답하기 위한 것이므로 실제 제품보다 훨씬 좋은 비용으로 빠르게 개발할 수 있다.

여러분에게 당장 중요하지 않은 세부 사항이라면 추후에 사용자에게 매우 중요해질지도 모르지만 일단 무시하면서 코딩할 수 있다.

하지만 세부 사항을 포기할 수 없는 환경에 처해 있다면 예광탄 방식의 개발이 더 적절할 것이다.

프로토타이핑으로 조사할 대상의 예는 다음과 같다.

- 아키텍처
- 기존 시스템에 추가할 새로운 기능
- 외부 데이터의 구조 혹은 내용
- 외부에서 가져온 도구나 컴포넌트
- 성능 문제
- 사용자 인터페이스 설계

프로토타입을 만들 때 무시해도 좋은 세부 사항은 다음과 같다.

1. 정확성
2. 완전성
3. 안정성
4. 스타일

프로토타입을 코드로 만들 때는 시작하기 전에 항상 모든 사람에게 여러분이 폐기 처분할 코드를 작성하고 있다는 사실을 이해시켜야 한다.

프로토타입을 모르는 사람에게는 오해를 살 정도로 매력적일 수도 있기 때문이다.

그러므로 코드는 폐기할 것이고, 불완전하며, 완성할 수 없다는 사실을 분명히 주지시켜야 한다.

만약 여러분이 작업하는 환경이나 문화에서 프로토타입 코드의 목적이 잘못 해설될 가능성이 크다고 느낀다면 예광탄 접근 방식을 취하는 편이 나을 것이다.
```
### Topic 14 도메인 언어
```text
컴퓨터 언어는 여러분이 문제에 대해, 또 의사소통에 대해 생각하는 방식에 영향을 미친다.

모든 언어는 제각기 일련의 특징들을 내세운다. 정적 타입 대 동적 타입, 이른 바인딩 대 늦은 바인딩, 함수형 대 객체 지향, 상속 모델, 믹스인, 매크로와 같은 유행어를 들먹인다.

이런 특징들은 모두 어떤 해결 방안을 제시하기도 하지만 가려 버리기도 한다.

문제 도메인의 언어가 어떤 프로그래밍 해결 방안을 제안하기도 하는데, 우리 생각에는 이것이 프로그래밍 언어의 사고방식보다 더 중요하다.

실용주의 프로그래머라면 어떤 경우에는 한 차원 더 나아가서 그 도메인의 실제 어휘와 문법, 의미론을 (그 도메인의 언어를)사용해서 프로그래밍할 수도 있다. 
```
### Topic 15 추정
```text
추정하는 법을 배우고 추정 능력을 계발하여 무언가의 규모를 직관적으로 짚을 정도가 되면, 추정 대산의 가능성을 가늠하는 마법과 같은 능력을 발휘할 수 있게 될 것이다.

어떤 의미에서 모든 답은 추정치다. 단지 어떤 답이 다른 답보다 좀 더 정확할 뿐이다.

추정에서 한 가지 재미있는 사실은 사용하는 단위가 결과의 해석의 차이를 가져온다는 것이다.

만약 무언가를 끝내는 데 근무일 기준으로 약 130일 동안 일해야 한다고 말하면 듣는 사람은 실제 소요 기간이 추정과 상당히 비슷하리라 기대할 것이다.

하지만 "아, 대략 6달 정도 걸리겠군요." 라고 말하면 지금부터 5~7달 사이 언젠자쯤 끝날 것이라 여길 것이다.

두 숫자는 같은 기간을 이야기하지만 '130일'은 실제 여러분의 느낌보다 더 정확도가 높으리라는 인상을 풍길 수 있다.

우리는 여러분이 기간을 추정할 때 다음과 같은 단위를 사용하기를 추천한다.

|1~15일  |일|
|3~6주   |주|
|8~20주  |달|
|20주 이상|추정치를 말하기 전에 다시 한번 생각해 보라.|

모든 추정치는 문제의 모델에 기반한다. 그런데 모델을 작성하는 기술에 대해 깊이 파고들기 전에 항상 좋은 답을 알려주는 기본적인 추정의 비법을 하나 밝히겠다.

이미 그 일을 해본 사람에게 물어보라. 똑같은 일을 해 본 사람을 찾기는 어렵겠지만, 놀라울 정도로 자주 다른 사람의 경험을 바탕으로 성공적인 추정치를 낼 수 있을 것이다.

어떤 종류의 추정을 하건 첫 단계는 상대방이 무엇을 묻고 있는지 이해하는 것이다.

정확도뿐 아니라 도메인에 존재하는 조건에 대해서도 감을 잡을 필요가 있다.

의뢰인의 요청을 이해한 후에는 간단하게 기본적인 것만 갖춘 개략적인 모델을 만들어 보라.

만약 응답 시간을 추정하고 있다면 여러분의 모델에는 서버와 서버에 도달하는 몇 가지 트래픽이 있어야 할 것이다.

프로젝트를 진행하고 있다면, 모델은 여러분의 조직이 개발하는 동안 사용할 발판이 될 뿐 아니라 시스템을 어떻게 구현해야 할지에 대한 밑그림을 제공해 줄 것이다.

모델을 만들어 추정을 하면 그 결과는 부정확해질 수밖에 없다. 하지만 이는 피할 수 없는 일이며, 또한 유익한 일이기도 하다.
```

## 3장 기본 도구
### Topic 16 일반 텍스트의 힘
### Topic 17 셀 가지고 놀기
### Topic 18 파워 에디팅
### Topic 19 버전 관리
### Topic 20 디버깅
### Topic 21 텍스트 처리
### Topic 22 엔지니어링 일지

## 4장 실용주의 편집증
### Topic 23 계약에 의한 설계
### Topic 24 죽은 프로그램은 거짓말을 하지 않는다
### Topic 25 단정적 프로그래밍
### Topic 26 리소스 사용의 균형
### Topic 27 헤드라이트를 앞서가지 말라

## 5장 구부리거나 부러지거나
### Topic 28 결함도 줄이기
### Topic 29 실세계를 갖고 저글링하기
### Topic 30 변환 프로그래밍
### Topic 31 상속세
### Topic 32 설정

## 6장 동시성
### Topic 33 시간적 결합 깨트리기
### Topic 34 공유 상태는 틀린 상태
### Topic 35 액터와 프로세스
### Topic 36 칠판

## 7장 코딩하는 동안
### Topic 37 파충류의 뇌에 귀 기울이기
### Topic 38 우연에 맡기는 프로그래밍
### Topic 39 알고리즘의 속도
### Topic 40 리팩터링
### Topic 41 테스트로 코딩하기
### Topic 42 속성 기반 테스트
### Topic 43 바깥에서는 안전에 주의하라
### Topic 44 이름 짓기

## 8장 프로젝트 전에
### Topic 45 요구 사항의 구렁텅이
### Topic 46 불가능한 퍼즐 풀기
### Topic 47 함께 일하기
### Topic 48 애자일의 핵심

## 9장 실용주의 프로젝트
### Topic 49 실용주의 팀
### Topic 50 코코넛만으로는 부족하다
### Topic 51 실용주의 시작 도구
### Topic 52 사용자를 기쁘게 하라
### Topic 53 오만과 편견
